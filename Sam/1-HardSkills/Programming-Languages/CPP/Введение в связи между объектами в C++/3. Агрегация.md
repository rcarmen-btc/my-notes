# Агрегация
На уроке о композиции мы говорили, что композиция объекта — это процесс создания сложных объектов из более простых. Мы также говорили о подтипе композиции объектов — композиции. В отношениях внутри композиции целое (класс) несет ответственность за существование частей (членов).

На этом уроке мы рассмотрим второй подтип композиции объекта — агрегацию.

Для реализации агрегации целое и его части должны соответствовать следующим отношениям:
- Часть (член) является частью целого (класса).
- Часть (член) может принадлежать более чем одному целому (классу) в моменте.
- Часть (член) существует, не управляемая целым (классом).
- Часть (член) не знает о существовании целого (класса).

Как и в случае с подтипом композиция, отношения в агрегации также являются отношениями части-целого и однонаправленные. Однако, в отличие от композиции, части могут принадлежать более чем одному целому в моменте, и целое не управляет существованием и продолжительностью жизни частей. При создании/уничтожении агрегации, целое не несет ответственности за создание/уничтожение своих частей.

Например, рассмотрим отношения между человеком и его домашним адресом. У каждого человека есть свой адрес. Однако этот адрес может принадлежать более чем одному человеку в моменте, например, вам и вашему соседу по комнате или родственникам, которые живут вместе с вами. К тому же этот адрес не управляется человеком — адрес существовал до того, как человек заселился и будет существовать после того, как человек выселится. Кроме того, человек знает, по какому адресу он живет, но адрес, в свою очередь, не знает, что это за человек и вообще, сколько их там находится. Такие отношения и являются агрегацией.

Поскольку агрегация подобна композиции, так как обе состоят из отношений части-целого, то они реализуются почти одинаково, а разница между ними в основном семантическая. В композиции мы добавляем части к целому, используя обычные переменные-члены (или указатели, когда в классе происходит динамическое выделение/освобождение памяти).

В агрегации мы также добавляем части к целому, используя переменные-члены. Однако этими переменными-членами обычно являются либо ссылки, либо указатели, которые указывают на объекты, созданные за пределами класса. Следовательно, агрегация принимает части, на которые она будет указывать, в качестве параметров конструктора или, если параметров нет, части добавляются позже через функции доступа или через перегруженные операторы.

Поскольку эти части существуют вне области видимости класса, то при уничтожении класса, переменные-члены в виде ссылок или указателей также уничтожаются (но не удаляются значения, на которые они указывают). Следовательно, сами части продолжают существовать дальше.

Рассмотрим пример Работника и Отдела детально. Чтобы было проще, в Отделе работает только один Работник и он не знает, Работником какого именно Отдела он является:

```cpp
#include <iostream> 
#include <string>
 
class Worker
{
private:
    std::string m_name;
 
public:
    Worker(std::string name)
        : m_name(name)
    {
    }
 
    std::string getName() { return m_name; }
};
 
class Department
{
private:
    Worker *m_worker; // чтобы было проще, в этом Отделе работает только один Работник, но их может быть и несколько
 
public:
    Department(Worker *worker = nullptr)
        : m_worker(worker)
    {
    }
};
 
int main()
{
    // Создаем Работника вне области видимости класса Department
    Worker *worker = new Worker("Anton"); // создаем Работника
    {
        // Создаем Отдел и передаем Работника в Отдел через параметр конструктора
        Department department(worker);
 
    } // department выходит из области видимости и уничтожается здесь
 
    // worker продолжает существовать дальше
 
    std::cout << worker->getName() << " still exists!";
 
    delete worker;
 
    return 0;
}
```

**Правило: Реализовывайте самые простые отношения, которые соответствуют потребностям вашей программы, а не то, что, как вам кажется, будет лучше.**

В композиции:
   - Используются обычные переменные-члены.
   - Используются указатели, если класс реализовывает собственное управление памятью (происходит динамическое выделение/освобождение памяти).
   - Класс ответственный за создание/уничтожение своих частей.

В агрегации:
   - Используются указатели/ссылки, которые указывают/ссылаются на части вне класса.
   - Класс не несет ответственности за создание/уничтожение своих частей.

