## Setup
---
- Файл __/etc/gitconfig__ содержит значения, действующие для всех пользователей системы и всех их репозиториев. Указав параметр --system при запуске git config, вы добьетесь чтения и записи для этого конкретного файла.
- Файл __~/.gitconfig__ или __~/.config/git/config__ связан с конкретным пользователем. Чтение и запись для этого файла инициируются передачей параметра `--global`.
- Параметры конфигурационного файла в папке Git (то есть __.git/config__) репозитория, с которым вы работаете в данный момент, действуют только на конкретный репозиторий.

```
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```

Передача параметра `--global` позволяет сделать эти настройки всего один раз, так как в этом случае Git будет использовать данную информацию для всеx ваших действий в системе. Если для конкретного проекта требуется указать другое имя или адрес электронной почты, войдите в папку с проектом и выполните эту команду без параметра `--global`.

Проверить выбранные настройки позволяет команда `git config --list`, выводящая список всех обнаруженных в текущий момент параметров

Чтобы начать слежение за существующим проектом, перейдите в папку этого проекта и введите команду:
```
$ git init
```

Клонирование репозитория осуществляется командой git clone [url]. К примеру, вот как клонируется подключаемая Git-библиотека libgit2:
```
$ git clone https://github.com/libgit2/libgit2
```

## Игнорирование файлов
Бывает так, что некоторый класс файлов вы не хотите ни автоматически добавлять в репозиторий, ни видеть в списке неотслеживаемых. В эту категорию, как правило, попадают автоматически генерируемые файлы, например журналы регистрации или файлы, генерируемые системой сборки. В подобных случаях создается файл .gitignore со списком соответствующих паттернов. Вот пример такого файла:
```
$ cat .gitignore
*.[oa]
*~
```

## Просмотр индексированных и неиндексированных изменений
Жизненный цикл состояния файлов:
![](Жизненный_цикл_состояния_файлов.png)

Основным инструментом определения состояния файлов является команда `git status`. 

Индексирование выполняется уже знакомой вам командой `git add`. Это многоцелевая команда, позволяющая начать **слежение за новыми файлами**, произвести **индексирование файлов**, а также **пометить файлы с конфликтом слияния как разрешенные**.

Запустив команду `git status -s` или `git status --short`, вы получите упрощенный
вариант вывода.

Если команда `git status` дает недостаточно подробный, с вашей точки зрения, результат, например если вы хотите не только получить список отредактированных файлов, но и узнать, что именно изменилось и не было проиндексировано, воспользуйтесь командой `git diff`.

Чтобы посмотреть, что из проиндексированного войдет в следующий коммит, вос-
пользуйтесь командой `git diff --staged`. Эта команда сравнивает индексированные
изменения с содержимым последней зафиксированной версии.

А команда `git diff --cached` покажет проиндексированные изменения.

## Фиксация изменений
Проще всего осуществить фиксацию командой:
```
$ git commit
$ git config --global core.editor # set your editor 
```

Если вам требуется более подробная информация об изменениях, можно добавить к команде `git commit` параметр `-v`. В результате в редакторе появится список изменений, включаемых в новые
фиксируемые данные. При выходе из редактора Git создает коммит с указанным сообщением (удаляя комментарии и список изменений).

## Пропуск области индексирования
`git commit -a -m "example"` - для фиксации в обход индексации.

## Удаление файлов
Это делает команда `git rm`, которая заодно удаляет указанный файл из рабочей папки, благодаря чему он исчезает из списка неотслеживаемых.

Иногда требуется оставить файл в рабочей папке, удалив его из области индексирования. В этом случае на помощь приходит параметр `--cached`:
`$ git rm --cached README`

При этом, как ни странно, в Git есть команда `mv`. Для переименования файла можно написать:
`$ git mv file_from file_to`

## Просмотр истории версий
После сохранения нескольких версий файлов или клонирования уже имеющего содержимое репозитория вы, скорее всего, захотите взглянуть на то, что было сделано ранее. Базовым и самым мощным инструментом в данном случае является команда `git log`.

Одним из самых полезных является параметр `-p`, показывающий разницу, внесенную каждым коммитом. А дополнительный параметр `-2` ограничивает выводимый результат последними двумя записями.
```
$ git log -p -2
```

Еще с командой `git log` могут использоваться группы суммирующих параметров. К примеру, для получения краткой статистики по каждой версии применяется параметр `--stat`.

Еще одним крайне полезным параметром является `--pretty`. Он меняет формат вывода информации. Есть несколько предустановленных вариантов. Параметр `oneline` выводит каждый коммит в одну строку, что весьма удобно при просмотре большого числа коммитов. Параметры `short`, `full` и `fuller`, практически не меняя формат вывода, определяют его детализацию:
```
$ git log --pretty=oneline
```

Наиболее интересен параметр `format`, позволяющий выводить записи журнала
в выбранном вами формате.
```
$ git log --pretty=format:"%h - %an, %ar : %s"
```

Параметры oneline и format особенно полезны в сочетании с другим параметром
команды log, который называется --graph. Он добавляет небольшой ASCII-граф
с историей ветвлений и слияний:
```
$ git log --pretty=format:"%h %s" --graph
```

## Ограничение вывода команды log
Параметры, устанавливающие ограничения по времени, такие как `--since` и `--until`. Вот пример команды, которая выводит список зафиксированных за последние две недели версий:
```
$ git log --since=2.weeks
```

Еще существует возможность фильтрации списка коммитов по какому-либо критерию. Параметр `--author` позволяет увидеть версии, созданные определенным автором, а параметр `--grep` дает возможность искать в сообщениях фиксации ключевые слова. Для одновременного поиска по этим критериям следует добавлять параметр `--all-match`, в противном случае в результаты попадет все то, что удовлетворяет либо первому, либо второму критерию.

Параметры, ограничивающие вывод команды `git log`:
- **-(n):** Показывает только последние n коммитов
- **--since, --after:** Показывает только коммиты, внесенные после указанной даты
- **--until, --before:** Показывает только коммиты, внесенные до указанной даты
- **--author:** Показывает только коммиты определенного автора
- **--committer:** Показывает только коммиты, внесенные определенным участником
- **--grep:** Показывает только коммиты с сообщением фиксации, содержащим указанную строку
- **-S:** Показывает только коммиты, в которых добавленный или удаленный код совпадает с указанной строкой

## Отмена изменений
Для повторного сохранения версии в такой ситуации можно воспользоваться параметром --amend:
```
$ git commit –amend
``` 
Эта команда берет область индексирования и включает в коммит всю обнаруженную там информацию.

## Отмена индексирования
```
git reset HEAD <имя файла>
```

> ПРИМЕЧАНИЕ С параметром `--hard` команда `git reset` может привести к опасным последствиям, так как в этом случае затрагиваются файлы в рабочей папке. Без этого параметра команда `git reset` совершенно безопасна, так как затрагивает только область индексирования.

## Псевдонимы в Git
```console
$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status
```

Такой способ может также быть полезен для создания команд, которые, как вы думаете, должны существовать. Например, чтобы исправить неудобство, с которым мы столкнулись при исключении файла из индекса, можно добавить в Git свой собственный псевдоним `unstage`:

```console
$ git config --global alias.unstage 'reset HEAD --'
```

Это делает эквивалентными следующие две команды:

```console
$ git unstage fileA
$ git reset HEAD -- fileA
```

Такой вариант кажется немного более понятным. Также, обычно, добавляют команду `last` следующим образом:

```console
$ git config --global alias.last 'log -1 HEAD'
```

Таким образом, можно легко просмотреть последний коммит:

```console
$ git last
```

Можно сказать, что Git просто заменяет эти команды на созданные вами псевдонимы (alias). Однако, возможно, вы захотите выполнить внешнюю команду, а не подкоманду Git. В этом случае, следует начать команду с символа `!`. Это полезно, если вы пишете свои утилиты для работы с Git-репозиторием. Продемонстрируем этот случай на примере создания псевдонима `git visual` для запуска `gitk`:

```console
$ git config --global alias.visual '!gitk'
```
